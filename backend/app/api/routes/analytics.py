"""Analytics API routes — agent performance, token usage, and social content metrics."""

from datetime import datetime, timedelta
from fastapi import APIRouter, Depends
from sqlalchemy import select, func, case, extract
from sqlalchemy.ext.asyncio import AsyncSession

from app.models.database import get_db, AgentTrace, Document, Metric
from app.models.schemas import AgentTraceResponse

router = APIRouter()


@router.get("/traces", response_model=list[AgentTraceResponse])
async def list_traces(
    agent_name: str = None,
    status: str = None,
    limit: int = 50,
    offset: int = 0,
    db: AsyncSession = Depends(get_db),
):
    """List agent execution traces."""
    query = select(AgentTrace).order_by(AgentTrace.started_at.desc())

    if agent_name:
        query = query.where(AgentTrace.agent_name == agent_name)
    if status:
        query = query.where(AgentTrace.status == status)

    result = await db.execute(query.offset(offset).limit(limit))
    traces = result.scalars().all()

    return [
        AgentTraceResponse(
            id=trace.id,
            agent_name=trace.agent_name,
            task_type=trace.task_type,
            status=trace.status,
            started_at=trace.started_at,
            completed_at=trace.completed_at,
            tokens_used=trace.tokens_used,
            error=trace.error,
        )
        for trace in traces
    ]


@router.get("/metrics")
async def get_metrics(
    period: str = "day",  # day, week, month
    db: AsyncSession = Depends(get_db),
):
    """Get performance metrics."""
    now = datetime.utcnow()

    if period == "day":
        since = now - timedelta(days=1)
    elif period == "week":
        since = now - timedelta(weeks=1)
    else:
        since = now - timedelta(days=30)

    # Agent execution stats
    trace_result = await db.execute(
        select(
            AgentTrace.agent_name,
            func.count(AgentTrace.id).label("count"),
            func.avg(AgentTrace.tokens_used).label("avg_tokens"),
        )
        .where(AgentTrace.started_at >= since)
        .group_by(AgentTrace.agent_name)
    )
    agent_stats = trace_result.all()

    return {
        "period": period,
        "since": since.isoformat(),
        "agent_stats": [
            {
                "agent": stat.agent_name,
                "executions": stat.count,
                "avg_tokens": round(stat.avg_tokens or 0, 2),
            }
            for stat in agent_stats
        ],
        "total_executions": sum(stat.count for stat in agent_stats),
    }


@router.get("/social")
async def get_social_analytics(
    period: str = "week",  # day, week, month
    db: AsyncSession = Depends(get_db),
):
    """Social media content analytics — generation times, agent utilization, token usage, and content output.

    Returns metrics designed for the hackathon evaluation:
    - Average content generation time per wave
    - Agent utilization breakdown (which agents run most)
    - Token usage by agent (cost awareness)
    - Content volume by platform and type
    """
    now = datetime.utcnow()

    if period == "day":
        since = now - timedelta(days=1)
    elif period == "week":
        since = now - timedelta(weeks=1)
    else:
        since = now - timedelta(days=30)

    # 1. Average content generation time (seconds) per agent
    duration_result = await db.execute(
        select(
            AgentTrace.agent_name,
            func.count(AgentTrace.id).label("executions"),
            func.avg(
                func.julianday(AgentTrace.completed_at) - func.julianday(AgentTrace.started_at)
            ).label("avg_duration_days"),
            func.sum(AgentTrace.tokens_used).label("total_tokens"),
            func.avg(AgentTrace.tokens_used).label("avg_tokens"),
            func.sum(case((AgentTrace.status == "completed", 1), else_=0)).label("successes"),
            func.sum(case((AgentTrace.status == "failed", 1), else_=0)).label("failures"),
        )
        .where(AgentTrace.started_at >= since)
        .group_by(AgentTrace.agent_name)
    )
    agent_rows = duration_result.all()

    agent_performance = []
    total_tokens = 0
    total_executions = 0

    for row in agent_rows:
        avg_seconds = (row.avg_duration_days or 0) * 86400  # Convert days to seconds
        agent_performance.append({
            "agent": row.agent_name,
            "executions": row.executions,
            "avg_duration_seconds": round(avg_seconds, 2),
            "total_tokens": row.total_tokens or 0,
            "avg_tokens": round(row.avg_tokens or 0),
            "success_rate": round(row.successes / row.executions * 100, 1) if row.executions else 0,
            "failures": row.failures or 0,
        })
        total_tokens += row.total_tokens or 0
        total_executions += row.executions

    # 2. Content volume — posts generated by type
    content_result = await db.execute(
        select(
            Document.doc_type,
            func.count(Document.id).label("count"),
        )
        .where(Document.created_at >= since)
        .group_by(Document.doc_type)
    )
    content_stats = {row.doc_type: row.count for row in content_result.all()}

    # 3. Orchestrator-level stats (overall content generation time)
    orchestrator_result = await db.execute(
        select(
            func.avg(
                func.julianday(AgentTrace.completed_at) - func.julianday(AgentTrace.started_at)
            ).label("avg_duration_days"),
            func.count(AgentTrace.id).label("count"),
        )
        .where(
            AgentTrace.agent_name == "orchestrator",
            AgentTrace.started_at >= since,
            AgentTrace.status == "completed",
        )
    )
    orch_row = orchestrator_result.one_or_none()
    avg_generation_seconds = ((orch_row.avg_duration_days or 0) * 86400) if orch_row else 0

    return {
        "period": period,
        "since": since.isoformat(),
        "summary": {
            "total_content_generated": sum(content_stats.values()),
            "social_posts": content_stats.get("social_post", 0),
            "avg_generation_seconds": round(avg_generation_seconds, 2),
            "total_agent_executions": total_executions,
            "total_tokens_used": total_tokens,
        },
        "agent_performance": sorted(agent_performance, key=lambda x: x["executions"], reverse=True),
        "content_by_type": content_stats,
    }
